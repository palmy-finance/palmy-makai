pragma solidity 0.8.10;
import "hardhat/console.sol";
import { WadRayMath } from "./libraries/WadRayMath.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

interface IERC20 {
  function transfer(address recipient, uint256 amount) external returns (bool);

  function approve(address spender, uint256 amount) external returns (bool);

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);

  function approveDelegation(address delegatee, uint256 amount) external;
}

/**
 * @title Palmy ERC20 LToken
 * @dev Implementation of the interest bearing token for the Palmy protocol
 * @author Palmy
 */
contract LToken {
  mapping(address => uint256) private _balances;

  mapping(address => mapping(address => uint256)) private _allowances;

  uint256 private _totalSupply;

  string private _name;
  string private _symbol;

  uint256 start_time;

  constructor(string memory name_, string memory symbol_) {
    _name = name_;
    _symbol = symbol_;
  }

  using WadRayMath for uint256;

  /**
   * @dev Mints `amount` lTokens to `user`
   * - Only callable by the LendingPool, as extra state updates there need to be managed
   * @param user The address receiving the minted tokens
   * @param amount The amount of tokens getting minted
   * @return `true` if the the previous balance of the user was 0
   */
  function mint(address user, uint256 amount) external returns (bool) {
    uint256 previousBalance = _balances[user];
    uint256 index = block.timestamp;

    uint256 amountScaled = amount.rayDiv(index);

    //console.log("minted amount is %s", amount);
    //console.log("minted scaled amount is %s", amount.rayDiv(index));

    _mint(user, amountScaled);

    return previousBalance == 0;
  }

  function _mint(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: mint to the zero address");
    _totalSupply += amount;
    _balances[account] += amount;
  }

  function mintToTreasury(address voter, uint256 amount) external {
    if (amount == 0) {
      return;
    }
    uint256 index = block.timestamp;

    //console.log("minted amount is %s", amount);
    //console.log("minted scaled amount is %s", amount.rayDiv(index));

    _mint(voter, amount.rayDiv(index));
  }

  /**
   * @dev Calculates the balance of the user: principal balance + interest generated by the principal
   * @param user The user whose balance is calculated
   * @return The balance of the user
   **/
  function balanceOf(address user) public view returns (uint256) {
    uint256 index = block.timestamp;
    //console.log("scaled balance is %s", _balances[user]);
    //console.log("balance is %s", _balances[user].rayMul(index));
    return _balances[user].rayMul(index);
  }

  function scaledBalanceOf(address user) external view returns (uint256) {
    return _balances[user];
  }

  /**
   * @dev Transfers the lTokens between two users. Validates the transfer
   * (ie checks for valid HF after the transfer) if required
   * @param from The source address
   * @param to The destination address
   * @param amount The amount getting transferred
   **/
  function _transfer(
    address from,
    address to,
    uint256 amount
  ) internal {
    uint256 index = block.timestamp;
    uint256 fromBalance = _balances[from];
    require(
      fromBalance >= amount.rayDiv(index),
      "ERC20: transfer amount exceeds balance"
    );
    unchecked {
      _balances[from] -= amount.rayDiv(index);
    }
    _balances[to] += amount.rayDiv(index);

    //console.log("transferred amount is %s", amount);
    //console.log("transferred scaled amount is %s", amount.rayDiv(index));
  }

  function approve(address spender, uint256 amount)
    public
    virtual
    returns (bool)
  {
    address owner = msg.sender;
    _approve(owner, spender, amount);
    return true;
  }

  function _approve(
    address owner,
    address spender,
    uint256 amount
  ) internal virtual {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = amount;
  }

  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual returns (bool) {
    _transfer(from, to, amount);
    return true;
  }

  function transfer(address to, uint256 amount) public virtual returns (bool) {
    address owner = msg.sender;
    _transfer(owner, to, amount);
    return true;
  }

  function transferUnderlyingTo(
    address asset,
    address target,
    uint256 amount
  ) external returns (uint256) {
    IERC20(asset).transfer(target, amount);
    return amount;
  }

  function burn(
    address asset,
    address user,
    address receiverOfUnderlying,
    uint256 amount
  ) external {
    uint256 index = block.timestamp;
    uint256 amountScaled = amount.rayDiv(index);
    //_burn(user, amountScaled);
    IERC20(asset).transfer(receiverOfUnderlying, amount);
  }

  function _burn(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: burn from the zero address");
    _balances[account] = _balances[account] - amount;
    _totalSupply = _totalSupply - amount;
  }
}
